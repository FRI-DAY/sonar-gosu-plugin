import com.hierynomus.gradle.license.tasks.LicenseFormat

plugins {
    id('antlr')
    id('java')
    id('jacoco')
    id('maven-publish')
    id('org.sonarqube') version('4.0.0.2929')
    id('com.github.johnrengelman.shadow') version('7.1.2')
    id('com.github.hierynomus.license') version('0.16.1')
}

repositories {
    mavenCentral()
}

sourceCompatibility = JavaVersion.toVersion(jdkMinVersion)
targetCompatibility = JavaVersion.toVersion(jdkMinVersion)

dependencies {
    antlr "org.antlr:antlr4:${antlrVersion}"

    compileOnlyApi "org.sonarsource.sonarqube:sonar-plugin-api:${sonarPluginApiVersion}"

    implementation "org.antlr:antlr4-runtime:${antlrVersion}"
    implementation "org.sonarsource.analyzer-commons:sonar-analyzer-commons:${sonarAnalyzerCommonsVersion}"
    implementation "org.sonarsource.java:java-surefire:${sonarJavaVersion}"

    implementation "org.apache.commons:commons-lang3:3.12.0"
    implementation "org.reflections:reflections:0.10.2"
    implementation "com.google.inject:guice:5.1.0"
    implementation "commons-io:commons-io:2.11.0"

    testImplementation "org.sonarsource.sonarqube:sonar-testing-harness:${sonarHarnessVersion}"
    testImplementation "org.assertj:assertj-core:3.24.2"
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.2'
    testImplementation 'org.junit.jupiter:junit-jupiter-engine:5.9.2'
    testImplementation 'org.junit.jupiter:junit-jupiter-params:5.9.2'
    testRuntimeOnly "org.sonarsource.sonarqube:sonar-plugin-api:${sonarPluginApiVersion}"
    testRuntimeOnly "ch.qos.logback:logback-classic:1.4.5"
}

def antlrGeneratedSourcesPath = ['de', 'friday', 'sonarqube', 'gosu', 'antlr']

generateGrammarSource {
    maxHeapSize = "128m"
    outputDirectory = file("${buildDir.path}/generated-src/antlr/main/${antlrGeneratedSourcesPath.join("/")}")
    arguments += ["-visitor", "-listener", "-package", antlrGeneratedSourcesPath.join(".")]

    finalizedBy("licenseFormatGeneratedSources")
}

tasks.register('licenseFormatGeneratedSources', LicenseFormat) {
    source = generateGrammarSource.outputDirectory
    dependsOn generateGrammarSource
    outputs.upToDateWhen { false }
}

compileJava {
    options.encoding = 'UTF-8'
    dependsOn generateGrammarSource
}

compileTestJava {
    options.encoding = 'UTF-8'
    dependsOn generateTestGrammarSource
}

tasks.licenseMain.shouldRunAfter generateGrammarSource

license {
    header = rootProject.file('LICENSE_HEADER')
    ext.year = Calendar.getInstance().get(Calendar.YEAR)
    strictCheck true
    mapping {
        java = 'SLASHSTAR_STYLE'
        g4 = 'DOUBLESLASH_STYLE'
    }
    excludes(['**/*.gs', '**/*.txt', '**/*.properties', '**/*.xml', '**/*.json', '**/*.xsd', '**/*.html', '**/*.vm', '**/*.snap', '**/*.svg', '**/*.jar', '**/*.zip', '**/*.log', '**/*.cnf', '**/*.jks', '**/README', '**/*.interp', '**/*.tokens'])
}

test {
    useJUnitPlatform()
    testLogging {
        showExceptions = true
        exceptionFormat = 'full'
        showStandardStreams = true
        events 'passed', 'skipped', 'failed'
    }
    finalizedBy jacocoTestReport
}

jacocoTestReport {
    reports {
        xml.required = true
        csv.required = false
        html.required = true
        html.outputLocation.set(file("$buildDir/jacocoHtml"))
    }

    //Excludes ANTLR generated sources
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [
                    "${antlrGeneratedSourcesPath.join("/")}/**",
            ])
        }))
    }
}

shadowJar {
    archiveBaseName = project.name
    archiveClassifier = ''
    configurations = [project.configurations.compileClasspath]
    mergeServiceFiles()
    dependencies {
        exclude(dependency('org.sonarsource.sonarqube:.*'))
        exclude(dependency('org.slf4j:.*'))
    }
    shouldRunAfter(tasks.check)
}

jar {
    archiveBaseName = project.name
    archiveClassifier = 'thin' //no dependencies included
    manifest {
        def pluginVersion = project.version
        def displayVersion = project.hasProperty('buildNumber') ? pluginVersion.substring(0, pluginVersion.lastIndexOf('.')) + " (build ${project.buildNumber})" : pluginVersion
        def buildDate = new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        attributes(
                'Build-Time': buildDate,
                'Implementation-Build': 'git rev-parse HEAD'.execute().text.trim(),
                'Plugin-BuildDate': buildDate,
                'Plugin-ChildFirstClassLoader': 'false',
                'Plugin-Class': 'de.friday.sonarqube.gosu.GosuPlugin',
                'Plugin-Description': 'Gosu Programming Language Plugin for SonarQube',
                'Plugin-Display-Version': displayVersion,
                'Plugin-IssueTrackerUrl': 'https://github.com/FRI-DAY/sonar-gosu-plugin/issues',
                'Plugin-Key': 'gosu',
                'Plugin-License': 'GNU AGPL 3',
                'Plugin-Name': 'FridayGosuPlugin',
                'Plugin-Organization': 'FRIDAY Insurance S.A.',
                'Plugin-OrganizationUrl': 'https://www.friday.de',
                'Plugin-SourcesUrl': 'https://github.com/FRI-DAY/sonar-gosu-plugin',
                'Plugin-Version': pluginVersion,
                'Sonar-Version': '6.7.7',
                'SonarLint-Supported': 'true',
                'Version': "${pluginVersion}",
        )
    }
}

java {
    withSourcesJar()
}

tasks.sourcesJar.dependsOn(tasks.generateGrammarSource)

artifacts {
    archives jar, shadowJar, sourcesJar
}
